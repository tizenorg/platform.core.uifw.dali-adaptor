#!/usr/bin/perl

use Git;
use Cwd;
use Cwd 'abs_path';
use File::Basename;
use File::Path;
use File::Copy;
use File::Copy::Recursive qw(dircopy);
use strict;
use Getopt::Long;
use Pod::Usage;

################################################################################
#                                SYSTEM PACKAGES                               #
################################################################################
# Add any required system packages to this list - if they are not present, then
# this script will attempt to install them for you.
my @system_packages = (
    "automake",
    "g++",
    "pkg-config",
    "libtool",
    "ccache",
    "libboost-dev",
    "libboost-thread-dev",
    "libelementary-dev",
    "libexif-dev",
    "libxml2-dev",
    "libgles2-mesa-dev",
    "libdrm-dev",
    "libgif-dev"
);

# Make best guess as to where this program was run from (note, it is
# always possible to override the location of $0 by the calling
# program, so we can't really tell for sure that this is where we
# expect it to be. :/

my $new_env   = 0;
my $exec_path = $0;
if($0 !~ m!^/!)
{
    $exec_path = abs_path($0);
}
$exec_path = dirname($exec_path);

my $root_path = getcwd();
if($exec_path =~ m!dali-env/opt/bin!)
{
    $root_path = $exec_path;
    while($root_path !~ m!dali-env$!)
    {
        $root_path = dirname($root_path);
    }
}
elsif($root_path =~ m!dali-env!)
{
    while($root_path !~ m!dali-env$!)
    {
        $root_path = dirname($root_path);
    }
}
else
{
    $new_env = 1;
    $root_path .= "/dali-env";
}

my $src_path     = "$root_path/src-packages";
my $sbs_path     = "$root_path/target";
my $install_path = "$root_path/opt";
#my $remote       = "srukgit1:29418";
my $remote       = "";

my $opt_build=-1;
my $opt_create=0;
my $opt_list=0;
my $opt_setenv=0;
my $opt_update=0;
my $opt_help=0;
my $opt_man=0;
my $opt_package="";
my $opt_user="";

GetOptions("build:s"    => \$opt_build,
           "create"     => \$opt_create,
           "list"       => \$opt_list,
           "package=s"  => \$opt_package,
           "authority=s"=> \$opt_user,
           "setenv"     => \$opt_setenv,
           "update"     => \$opt_update,
           "help"       => \$opt_help,
           "man"        => \$opt_man) or pod2usage(2);

pod2usage(1) if $opt_help;
pod2usage(-exitstatus => 0, -verbose => 2) if $opt_man;


################################################################################

if($opt_user ne "")
{
    $remote = "ssh://$opt_user" . '@' . $remote;
}
else
{
    $remote = "ssh://$remote";
}

################################################################################

sub print_paths
{
    print "root_path    = $root_path\n";
    print "src_path     = $src_path\n";
    print "sbs_path     = $sbs_path\n";
    print "install_path = $install_path\n";
}

################################################################################
# Wrap system call with environment, and stop if fails.
sub run
{
    my $argref = shift;
    my $envref = shift;
    my $envunsetref = shift;

    my @cmd = ();
    push @cmd, "env" if $envref || $envunsetref;

    if($envref)
    {
        push @cmd, map { $_ . "=" . $envref->{$_} } keys(%$envref);
    }
    if($envunsetref)
    {
        foreach my $var (@$envunsetref)
        {
            push(@cmd, "-u", $var)
        }
    }
    push(@cmd, @$argref);
    print "Running @cmd: \n";
    my $ret = system(@cmd);
    if($ret >> 8) { die "Can't run @cmd: $!\n"; }
}

################################################################################

sub get_archive_revision
{
    my $remote   = shift;
    my $repo     = shift;
    my $commit   = shift;

    my $rev=`git ls-remote "$remote$repo" "$commit" | head -1 | cut -f1`;
    chomp($rev);

    #print "Latest revision: $rev\n";
    return $rev;
}

################################################################################

sub unzip_archive
{
# Do nothing for a clone. Uncomment if using git-archive works

#    my $src_path = shift;
#    my $name = shift;
#
#    my $srcfile="$src_path/$name.zip";
#    my $srcdir="$src_path/$name";
#    rmtree($srcdir);
#    mkdir($srcdir);
#    my @cmd = ("unzip", "-qq", "-d", "$srcdir",  "$srcfile");
#    system(@cmd);
}

################################################################################
# Get archive name
sub get_archive_name
{
    my $name = shift;
    return $name;
# return $name . ".zip";
}

################################################################################
# Get Git repository from gitserver. Removes any existing un-archive trees
sub get_archive
{
    my $remote   = shift;
    my $repo     = shift;
    my $name     = shift;
    my $src_path = shift;

    my $archivename = get_archive_name($name);
    my $srcdir="$src_path/$archivename";

    print "Downloading $archivename... \n";

    print `rm -rf $archivename`; # remove old clone first
    my $rev = get_archive_revision($remote, $repo, "refs/heads/master");
    `echo $rev > $src_path/$name.commit_id`;
# For Gerrit, use a shallow clone instead of archive - can't push/pull with it.

    print "Running git clone --depth=1 $remote$repo $srcdir\n";
    print `git clone --depth=1 $remote$repo $srcdir`;
# Only works with a git stack that supports git-upload-archive (Gerrit doesn't)
# my $srcfile="$src_path/" . get_archive_name($name);
# print `git archive --format=zip --remote=$remote$repo HEAD > $srcfile`;
# if(! -f $srcfile)
# {
#   die "Can't get archive:\n";
# }

#    Only works on git 1.7
#    my @cmd = ("git", "archive", "--remote=$remote$repo", "$rev", "-o", "$srcfile");

}

################################################################################
# Return TRUE if archive requires updating
sub check_archive
{
    my $remote   = shift;
    my $repo     = shift;
    my $name     = shift;
    my $src_path = shift;

    my $archive_name = get_archive_name($name);
    if( ! -e "$src_path/$archive_name" )
    {
        return 1;
    }
    else
    {
        my $latest_rev  = get_archive_revision($remote, $repo, "refs/heads/master");
        my $cur_rev = "";
        if(-e "$src_path/$name.commit_id")
        {
            $cur_rev = `cat $src_path/$name.commit_id`;
            chomp $cur_rev;
        }
        return $cur_rev ne $latest_rev;
    }
}

################################################################################

sub update_archive
{
    my $remote   = shift;
    my $repo     = shift;
    my $name     = shift;
    my $src_path = shift;

    my $updated = 0;
    if(check_archive($remote, $repo, $name, $src_path))
    {
        get_archive($remote, $repo, $name, $src_path);
        $updated = 1;
    }
    else
    {
        print "Package $name already up to date\n";
    }
    return $updated;
}

################################################################################

sub create_env
{
    mkpath("$install_path/bin");
    mkpath("$install_path/lib/pkgconfig");
    mkpath("$install_path/include");
    mkpath("$install_path/share/aclocal");
    mkpath("$src_path");
    mkpath("$sbs_path");

    copy($0, "$install_path/bin/dali_env");
    chmod(0755, "$install_path/bin/dali_env");
}

################################################################################

sub in_dali_env
{
    my $cwd = substr(getcwd(), 0, length($root_path));
    #print "cwd = $cwd\nroot = $root_path\n";
    return $cwd eq $root_path;
}

################################################################################

sub create_setenv
{
    print <<"EOF";
# To use the desktop libraries, please add the following lines to your .bashrc or
# create a setenv script from them, e.g. by running this command as follows
# \$ dali_env -s > setenv
#
# You can then source this script by using
# \$ . setenv
#
# Use DESKTOP_PREFIX when running configure in dali/build/slp:
# \$ CXXFLAGS="-g -O0" ./configure --prefix=\$DESKTOP_PREFIX --without-libccss

export DESKTOP_PREFIX=$install_path
export PATH=$install_path/bin:\$PATH
export LD_LIBRARY_PATH=$install_path/lib:\$LD_LIBRARY_PATH
export INCLUDEDIR=$install_path/include
export PKG_CONFIG_PATH=$install_path/lib/pkgconfig:/usr/lib/pkgconfig:/usr/share/pkgconfig

EOF
}

################################################################################

sub check_system_package
{
    my $package;
    foreach $package (@_)
    {
        my @x=split(/\s+/, `dpkg -l $package|grep $package`);
        if($x[0] ne "ii")
        {
            print "Attempting to install $package\n";
            system("sudo apt-get -y install $package");
        }
    }
}

sub check_system_packages
{
    print "Checking for required system packages (may require sudo password)\n";

    check_system_package(@system_packages);
    my $gnome_v =`dpkg -l gnome-common| tail -1| sed "s/ \\+/ /g" | cut -d' ' -f 3`;
    my @am = split(/\./, `automake --version | head -1 | cut -f4 -d' '`);
    if($gnome_v =~ /$2.24/ && $am[1]>10)
    {
        die "Gnome common and automake are not compatible - automake is too new\n";
    }
    my @gpp_v = (`g++ --version  | head -1` =~ /(\d+)\.(\d+)\.(\d+)/);

    if(! (($gpp_v[0] > 4)
          ||
          ($gpp_v[0] == 4 && $gpp_v[1] > 4)
          ||
          ($gpp_v[0] == 4 && $gpp_v[1] == 4 && $gpp_v[2] >= 5)))
    {
        die "You need g++ 4.5.1 or greater to build dali\n";
    }
}


################################################################################
#                                       MAIN
################################################################################


if($opt_create)
{
    my $new_root = getcwd() . "/dali-env";

    if($exec_path =~ m!dali-env/opt/bin!)
    {
        die "Already in a dali-env directory\n";
        # Could query if user wants to re-create?
    }
    elsif(-e $new_root)
    {
        die "A dali-env directory already exists here\n";
    }

    check_system_packages();

    create_env();
    create_setenv();
}
elsif($opt_update)
{
    if(! -d $root_path)
    {
        die "$root_path does not exist\n";
    }
    chdir $src_path;
    check_system_packages();
    create_setenv();
}

elsif($opt_build != -1)
{
    if(! -d $root_path)
    {
        die "$root_path does not exist\n";
    }

    check_system_packages();
}
elsif($opt_setenv)
{
    if(! -d $root_path)
    {
        die "$root_path does not exist\n";
    }
    elsif($new_env)
    {
        die "$root_path is not an existing environment\n";
    }
    create_setenv();
}
else
{
    pod2usage(1);
}

__END__

=head1 NAME

dali_env - Install / update / rebuild the dali environment for desktop and scratchbox

=head1 SYNOPSIS

dali_env [-c|-u|-b]  [-a <user>] [-s] [-h|-m]

=head1 OPTIONS

=over 28

=item B<-c|--create>

Create a dali environment directory in the current directory.

=item B<-u|--update>

Update and rebuild the current dali environment only if necessary. Only builds for desktop.

=item B<-b|--build [target]>

Force rebuild the current packages. With no target option, it rebuilds
for desktop only.
Using a target of "both" builds desktop & scratchbox; using a target of "sbs"/"scratcbox" builds only the scratchbox packages.

=item B<-a|--auth [user]>

Set the user for git authorisation

=item B<-l|--list>

Display the local packages

=item B<-p|--package>

Specify a particular package to update / build

=item B<-s|--setenv>

Display environment variables to setup.

=item B<-h|--help>

Display this help

=item B<-m|--man>

Display the manual page

=back

=head1 DESCRIPTION

B<dali_env>

Gets and builds the required packages for Dali. For desktop, installs them to a local directory, and creates a setenv script to point to the installation. For scratchbox, creates the debian packages for you to install.

=cut
